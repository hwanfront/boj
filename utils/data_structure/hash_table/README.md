# 직접 주소 테이블 direct address table
key 값 그대로 index 위치에 저장하는 단순한 기법입니다.
list 나 array 에 그대로 추가한다고 생각하시면 됩니다.
만약에 학번을 기준으로 저장을 하고싶은 경우에는 어떻게 될까요?
2024001 2024002 2024003 ...
사용하지도 않는 0~2024000 까지의 메모리를 낭비하게 됩니다.
또한 키가 문자열인 경우에는 또 어떻게 해야할까요?
# Hash Table
해시 테이블은 key 와 value 로 구성된 자료구조입니다.
key 값은 Hash Function 을 통해 변환된 해시값을 생성합니다. 
특정 범위의 정수로 변환된 해시값의 인덱스에 데이터를 저장합니다.
데이터 크기에 상관없이 삽입 삭제 검색 시간이 O(1)로 빠릅니다.
## 버킷
해시 함수의 결과에 따라 데이터를 저장하는 메모리 즉 저장 공간을 의미합니다.
시간 복잡도
- search: Θ(1), O(n)
- add: Θ(1), O(n)
- remove: Θ(1), O(n)
# Hash Collision
hashing 중에 두 개 이상의 키가 동일한 위치에 해싱되는 경우를 Collision 이라고 합니다.
## 체이닝 Chaining
Hash Collision 이 발생했을 때 동일한 인덱스에 여러 개의 값을 저장할 수 있게 합니다.
각 해시 테이블의 버킷에서 Linked List 등을 사용하는 방법입니다.
Hash Collision 이 발생하면 리스트에 새로운 값을 삽입합니다.
다만 리스트가 길어지면 탐색이 느려질 수 있고, 추가적인 메모리 공간이 필요합니다.
## 개방주소법 open addressing
개방 주소법은 충돌 발생 시, 다른 빈 버킷을 찾아 데이터를 저장하는 방법이며 추가적인 탐색 방법이 필요합니다.
선형탐사법 ; 충돌이 발생하면 고정된 간격으로 다음 빈 버킷을 찾아 삽입합니다. 군집화가 발생할 수 있습니다.
제곱탐사법 ; 충돌이 발생하면 제곱 간격으로 다음 빈 버킷을 찾아 삽입합니다. 테이블 크기가 작은 경우 충돌이 많이 발생할 수 있습니다.
이중해싱 ; 충돌이 발생하면 이전에 사용한 해시함수가 아닌 두번째 해시함수를 사용합니다.


## Hash Table 의 특징
- 체이닝(Chaining), 개방 주소법(Open Addressing) 등으로 충돌을 관리합니다.
## Complexity
### Time Complexity
- search: Θ(1), O(n)
- add: Θ(1), O(n)
- remove: Θ(1), O(n)
### Space Complexity
- O(n)